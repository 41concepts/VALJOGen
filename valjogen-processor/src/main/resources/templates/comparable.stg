method_compareTo(clazz, method) ::= <<
<declare_method(clazz, method)>
{
  int <uniqueVariableName(clazz,"result")>;

  <clazz.members:{m | <(comparableTemplateNamesByTypeCategory.(m.type.typeCategory))(clazz, first(method.parameters), m, m.type)>}; wrap, anchor, separator="\n\n">

  return 0;
}
>>

comparableTemplateNamesByTypeCategory ::= [ "PRIMITIVE": "comparable_primitive", "ARRAY": "comparable_array", default: "comparable_object"]

comparable_primitive(clazz, other, member, type) ::= <<
if ((<uniqueVariableName(clazz,"result")>=<type.wrapperName>.compare(<member.name>, <other_instance_get_member_value(other, member)>))!=0)
 return <uniqueVariableName(clazz,"result")>;
>>

comparable_array(clazz, param, var, type) ::= <<
<! Comparing arrays not supported !>
>>

comparable_object(clazz, other, member, type) ::= <<
<if(type.comparable && (other.type.thisType || member.getter))>
if ((<uniqueVariableName(clazz,"result")>=<member.name>.compareTo(<other_instance_get_member_value(other, member)>))!=0)
 return <uniqueVariableName(clazz,"result")>;
<else>
<! Comparing non-comparable objects or members through interfaces without getters not supported !>
<endif>
>>
