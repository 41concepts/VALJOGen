/**
* Copyright (C) 2014 41concepts Aps
*
* This is the main template group file for ValjoGen in StringTemplate v4 format (see "http://www.stringtemplate.org" for details).

* All templates mention here and in associated files may be overridden by a custom template group file. However it is safer just to override one or
* more of the many <@regions> that the templates declare. Note that regions has access to arguments of the declaring scope so they are very powerful.
*
* The main entry point is the class template that the controller is calling with a instance of the com.fortyoneconcepts.valjogen.model.Clazz model. The templates
* use instances of this model and related models in the same package.
*
* Do note that because of StringTemplates strict seperation rules, the templates can only query for boolean properties. Other kinds of logic is not possible.
**/

import "common.stg"
import "property.stg"
import "hash.stg"
import "equals.stg"
import "comparable.stg"
import "tostring.stg"
import "javadoc.stg"

/** Generate class (main entry point). Called with an instance of the Clazz model **/
class(clazz) ::= <<
<clazz.fileHeaderText>
<if(!clazz.inDefaultPackage)>
package <clazz.packageName>;
<endif>

<@imports><clazz.importTypes:importStatement(); separator="\n"><@end>

<@javadoc><@end>
<@annotations><@end>
<@generated>@<clazz.helperTypes.generatedAnnotation.name>(value = "com.fortyoneconcepts.valjogen", date="<clazz.configuration.executionDate>", comments="Generated by ValjoGen code generator (ValjoGen.41concepts.com) from <clazz.masterName>")<@end>
<optScope(clazz)><optFinal(clazz)><optAbstract(clazz)>class <clazz.prototypicalName><optBaseClass(clazz)> implements <clazz.interfaceTypes:{ _i |<_i.prototypicalName>}; wrap, anchor, separator=", ">
{
  <! Static class members: !>
  <@before_class_members><@end>
  <if(clazz.serializable && clazz.configuration.serialVersionUIDSpecified)>
  private static final long serialVersionUID = <clazz.configuration.serialVersionUID>;

  <endif>
  <@after_class_members><@end>
  <! Instance members: !>
  <@before_instance_members><@end>
  <clazz.members:member(); separator="\n">
  <@after_instance_members><@end>

  <! Static methods incl. factory: !>
  <@before_class_methods><@end>
  <if(!clazz.abstract && clazz.configuration.staticFactoryMethodEnabled)>
  <method_valueOf(clazz)>

  <endif>
  <@after_class_methods><@end>
  <! Instance methods and constructor: !>
  <@before_instance_methods><@end>
  <method_this(clazz)>

  <clazz.propertyMethods:property(); separator="\n\n">

  <! Call template methods corresponding to prefixed method names !>
  <clazz.claimedImplementationMethods:{m | <(implementationMethod(m.name))(clazz, m)>}; separator="\n\n">
  <@after_instance_methods><@end>
}
>>

/** Generate an import statement **/
importStatement(type) ::= <<
import <type.qualifiedName>;
>>

/** Generate a class instance member **/
member(member) ::= <<
<@javadoc><@end><@annotations><@end><\\>
<internalLevel(member.clazz)><optFinal(member)><member.type.name> <member.name>;
>>

/** Generate constructor **/
method_this(clazz) ::= <<
<@javadoc><@end><@annotations><@end>
<constructorLevel(clazz)><clazz.name>(<clazz.members:formalParameter(); wrap, anchor, separator=", ">)
{
  <if(!clazz.baseClazzType.rootObject)>super();<endif>
  <@preamble><@end>
  <clazz.members:{p | this.<p.name>=<guard(p, p)>;}; wrap, anchor, separator="\n">
  <@postamble><@end>
}
>>

/** Generate static factory method: **/
method_valueOf(clazz) ::= <<
<@javadoc><@end><@annotations><@end>
public static <optGenericQualifier(clazz)><clazz.prototypicalName> valueOf(<clazz.members:formalParameter(); wrap, anchor, separator=", ">)
{
  <@preamble><@end>
  <clazz.prototypicalName> <uniqueVariableName(clazz,"instance")> = new <clazz.name>(<clazz.members:{m | <m.name>}; wrap, anchor, separator=", ">);
  <@postamble><@end>
  return <@returnvalue><uniqueVariableName(clazz,"instance")><@end>;
}
>>
